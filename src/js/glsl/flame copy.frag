// Fragment Shader

uniform float uTime;
uniform float uRandom;
uniform vec2 uMouse;
uniform sampler2D uTexture;

varying vec2 vUv;






//---------------------------------------------------------------------- CURL


vec4 permute(vec4 x){return mod(x*x*34.+x,289.);}

float snoise(vec3 v){
  const vec2 C = 1./vec2(6,3);
  const vec4 D = vec4(0,.5,1,2);
  vec3 i  = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1. - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );
  vec3 x1 = x0 - i1 + C.x;
  vec3 x2 = x0 - i2 + C.y;
  vec3 x3 = x0 - D.yyy;
  i = mod(i,289.);
  vec4 p = permute( permute( permute(
	  i.z + vec4(0., i1.z, i2.z, 1.))
	+ i.y + vec4(0., i1.y, i2.y, 1.))
	+ i.x + vec4(0., i1.x, i2.x, 1.));
  vec3 ns = .142857142857 * D.wyz - D.xzx;
  vec4 j = p - 49. * floor(p * ns.z * ns.z);
  vec4 x_ = floor(j * ns.z);
  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = floor(j - 7. * x_ ) *ns.x + ns.yyyy;
  vec4 h = 1. - abs(x) - abs(y);
  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );
  vec4 sh = -step(h, vec4(0));
  vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww ;
  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);
  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);
  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );
}

vec3 snoiseVec3( vec3 x ){
  return vec3(  snoise(vec3( x )*2.-1.),
								snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ))*2.-1.,
								snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 )*2.-1.)
	);
}

vec3 curlNoise( vec3 p ){
  const float e = .1;
  vec3 dx = vec3( e   , 0.0 , 0.0 );
  vec3 dy = vec3( 0.0 , e   , 0.0 );
  vec3 dz = vec3( 0.0 , 0.0 , e   );

  vec3 p_x0 = snoiseVec3( p - dx );
  vec3 p_x1 = snoiseVec3( p + dx );
  vec3 p_y0 = snoiseVec3( p - dy );
  vec3 p_y1 = snoiseVec3( p + dy );
  vec3 p_z0 = snoiseVec3( p - dz );
  vec3 p_z1 = snoiseVec3( p + dz );

  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

  const float divisor = 1.0 / ( 2.0 * e );
  return normalize( vec3( x , y , z ) * divisor );
}






vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }





float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}



vec2 rotateUv  (vec2 uv, float angle) {
  return vec2(
    uv.x * cos(angle) - uv.y * sin(angle),
    uv.x * sin(angle) + uv.y * cos(angle)
  );
}

const float PI = 3.14159265359;
void main() {
  vec2 uv = vUv;
  vec2 uv3 = vUv;
  vec2 uv2= uv*2.-1.;

  float noise5 = snoise(-uv * 1. + (uTime*0.3));

  vec2 mouseUv = uMouse +noise5*.3;
  float mouseDistance= distance(uv2, mouseUv);
  float radiusMouseFromCenter= atan(1., mouseUv.x) - PI/2.;
  //float radiusUv= atan(uMouse.y, uMouse.x);

  float noise1 = snoise(-uv * 7. + (uTime*0.3));
  float noise4 = snoise(-uv * 2. + (uTime*0.05));


  //uv2 = rotateUv(uv2, -radiusMouseFromCenter * .5*pow(uv.y,2.) * noise4);
  uv2 = rotateUv(uv2, -radiusMouseFromCenter
  *
    pow(  smoothstep(0.,5., pow(2./mouseDistance,1.)*1. ),1.)
     *1.2*uv.y );

  uv = uv2*0.5+0.5;




  float noise2 = snoise(-uv * 2. + (uTime*0.2));
  float noise3 = snoise(
    vec2(
      pow(uv.x, 0.)*0.,
      -pow(uv.y, 10.)*2.+uTime * uRandom
    )
  );
  gl_FragColor = texture2D(uTexture, uv+noise1*0.003+ noise2*0.013);

  // gl_FragColor = vec4(vec3(uv.y),1.);

uv.x = uv.x + noise3*0.007 * uv.y;

 vec4 color = texture2D(uTexture,    uv+noise1*0.003* uv.y+ noise2*0.013);

  gl_FragColor = texture2D(uTexture, uv+
  pow(  smoothstep(0.,6., pow(2./mouseDistance,1.)*1. ),2.) * (4.783)
  *
  noise1*0.003* uv.y+ noise2*0.013);

  vec3 cNoise1 = curlNoise(vec3(uv.x*0.2,uv.y*0.2,uTime*0.2) );

  vec2 uv4 = vec2(uv.x + cNoise1.x*0.013,uv.y + cNoise1.y*0.013 );
  gl_FragColor = texture2D(uTexture, uv4);

//  gl_FragColor = vec4(vec3(mouseDistance), 1.);

}