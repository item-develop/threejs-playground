<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Animated Line Shader with Progress</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      line-height: 1.6;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-family: monospace;
    }
    input[type="range"] {
      width: 200px;
      margin: 0 10px;
    }
  </style>
</head>
<body>
  <div id="info">
    マウスドラッグで回転<br>
    線の進捗アニメーション<br>
    <span id="offset-value">Offset: 0.00</span>
  </div>
  <div id="controls">
    <label>Start: <input type="range" id="startSlider" min="0" max="1" step="0.01" value="0"></label>
    <label>End: <input type="range" id="endSlider" min="0" max="1" step="0.01" value="1"></label>
    <button id="animateBtn">アニメーション開始</button>
  </div>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';

    // 頂点シェーダー
    const vertexShader = `
      precision highp float;
      
      uniform float uTime;
      uniform float uWidth;
      uniform vec2 uResolution;
      uniform vec2 uMouse;
      uniform float uStart;
      uniform float uEnd;
      
      attribute vec3 aPrev;
      attribute vec3 aNext;
      attribute float aSide;
      attribute float aProgress;
      
      varying float vProgress;
      varying float vSide;
      varying float vShow;
      
      mat3 rotateY(float angle) {
        float s = sin(angle);
        float c = cos(angle);
        return mat3(
          c, 0.0, s,
          0.0, 1.0, 0.0,
          -s, 0.0, c
        );
      }
      
      mat3 rotateX(float angle) {
        float s = sin(angle);
        float c = cos(angle);
        return mat3(
          1.0, 0.0, 0.0,
          0.0, c, -s,
          0.0, s, c
        );
      }
      
      void main() {
        // 表示範囲の計算
        float show = 0.0;
        float fadeWidth = 0.05; // フェードの幅
        
        if (aProgress >= uStart && aProgress <= uEnd) {
          show = 1.0;
          
          // 始点付近でフェードイン
          if (aProgress < uStart + fadeWidth) {
            show = smoothstep(uStart, uStart + fadeWidth, aProgress);
          }
          
          // 終点付近でフェードアウト
          if (aProgress > uEnd - fadeWidth) {
            show = smoothstep(uEnd, uEnd - fadeWidth, aProgress);
          }
        }
        
        // マウスによる回転
        vec3 pos = position;
        vec3 prev = aPrev;
        vec3 next = aNext;
        
        pos = rotateY(uMouse.x) * pos;
        pos = rotateX(uMouse.y) * pos;
        prev = rotateY(uMouse.x) * prev;
        prev = rotateX(uMouse.y) * prev;
        next = rotateY(uMouse.x) * next;
        next = rotateX(uMouse.y) * next;
        
        // ビュー・プロジェクション変換
        vec4 currMV = modelViewMatrix * vec4(pos, 1.0);
        vec4 prevMV = modelViewMatrix * vec4(prev, 1.0);
        vec4 nextMV = modelViewMatrix * vec4(next, 1.0);
        
        vec4 clipCurr = projectionMatrix * currMV;
        vec4 clipPrev = projectionMatrix * prevMV;
        vec4 clipNext = projectionMatrix * nextMV;
        
        // NDC空間に変換
        vec2 ndcCurr = clipCurr.xy / clipCurr.w;
        vec2 ndcPrev = clipPrev.xy / clipPrev.w;
        vec2 ndcNext = clipNext.xy / clipNext.w;
        
        // 線の方向を計算
        vec2 dir = normalize(ndcNext - ndcPrev);
        if (length(ndcNext - ndcPrev) < 0.0001) {
          dir = vec2(1.0, 0.0);
        }
        
        // 垂直方向のオフセット（ビルボード）
        vec2 normal = vec2(-dir.y, dir.x);
        
        // ピクセル単位でのオフセット（表示状態に応じて幅を調整）
        vec2 ndcPerPixel = 2.0 / uResolution;
        vec2 offset = normal * aSide * uWidth * show * ndcPerPixel;
        
        vec4 finalPos = clipCurr;
        finalPos.xy += offset * clipCurr.w;
        
        gl_Position = finalPos;
        
        vProgress = aProgress;
        vSide = aSide;
        vShow = show;
        vUv = vec2(aProgress, aSide); // progress(0-1), side(-1 to 1)
      }
    `;

    // フラグメントシェーダー
    const fragmentShader = `
      precision highp float;
      
      uniform vec3 uColor;
      uniform float uStart;
      uniform float uEnd;
      
      varying float vProgress;
      varying float vSide;
      varying float vShow;
      
      varying vec2 vUv; // 追加: セグメント内のUV座標
      
      void main() {
        // 表示範囲外は破棄
        if (vShow < 0.01) {
          discard;
        }
        
        // 先端を丸くする処理
        float fadeWidth = 0.05;
        float alpha = 1.0;
        
        // 開始点付近で丸める
        if (vProgress < uStart + fadeWidth) {
          float distFromStart = (vProgress - uStart) / fadeWidth;
          float capDist = length(vec2(distFromStart, vSide));
          if (capDist > 1.0) {
            discard;
          }
          alpha *= smoothstep(1.0, 0.8, capDist);
        }
        
        // 終了点付近で丸める
        if (vProgress > uEnd - fadeWidth) {
          float distFromEnd = (uEnd - vProgress) / fadeWidth;
          float capDist = length(vec2(distFromEnd, vSide));
          if (capDist > 1.0) {
            discard;
          }
          alpha *= smoothstep(1.0, 0.8, capDist);
        }
        
        // 進捗に応じたグラデーション
        float normalizedProgress = (vProgress - uStart) / max(uEnd - uStart, 0.001);
        vec3 color = mix(uColor * 0.5, uColor * 1.5, normalizedProgress);
        
        // エッジを少しソフトに
        float edgeFade = smoothstep(0.95, 0.85, abs(vSide));
        
        gl_FragColor = vec4(color, vShow * edgeFade * alpha);
      }
    `;

    // ラインジオメトリを作成する関数
    function createLineGeometry(points) {
      const positions = [];
      const prevPositions = [];
      const nextPositions = [];
      const sides = [];
      const progress = [];
      const indices = [];
      
      const numPoints = points.length;
      
      for (let i = 0; i < numPoints; i++) {
        const curr = points[i];
        const prev = i > 0 ? points[i - 1] : points[i];
        const next = i < numPoints - 1 ? points[i + 1] : points[i];
        
        const prog = i / (numPoints - 1);
        
        // 各点から2つの頂点を作成（両側）
        for (let side = 0; side < 2; side++) {
          positions.push(curr.x, curr.y, curr.z);
          prevPositions.push(prev.x, prev.y, prev.z);
          nextPositions.push(next.x, next.y, next.z);
          sides.push(side === 0 ? 1 : -1);
          progress.push(prog);
        }
        
        // インデックス（四角形を2つの三角形に）
        if (i < numPoints - 1) {
          const base = i * 2;
          indices.push(base, base + 1, base + 2);
          indices.push(base + 2, base + 1, base + 3);
        }
      }
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('aPrev', new THREE.Float32BufferAttribute(prevPositions, 3));
      geometry.setAttribute('aNext', new THREE.Float32BufferAttribute(nextPositions, 3));
      geometry.setAttribute('aSide', new THREE.Float32BufferAttribute(sides, 1));
      geometry.setAttribute('aProgress', new THREE.Float32BufferAttribute(progress, 1));
      geometry.setIndex(indices);
      
      return geometry;
    }

    // シーンのセットアップ
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 6;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // マウス操作
    const mouse = new THREE.Vector2(0, 0);
    let isDragging = false;
    
    renderer.domElement.addEventListener('mousedown', () => isDragging = true);
    renderer.domElement.addEventListener('mouseup', () => isDragging = false);
    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        mouse.x += e.movementX * 0.005;
        mouse.y += e.movementY * 0.005;
        mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
      }
    });

    // アニメーション制御
    let isAnimating = false;
    let animationStart = 0;
    const animationDuration = 3000; // 3秒

    // UI要素
    const startSlider = document.getElementById('startSlider');
    const endSlider = document.getElementById('endSlider');
    const animateBtn = document.getElementById('animateBtn');
    const offsetValue = document.getElementById('offset-value');

    // 複数の線を作成
    const lines = [];
    
    // 1. スパイラル
    const spiralPoints = [];
    for (let i = 0; i < 80; i++) {
      const t = i / 79;
      const angle = t * Math.PI * 4;
      const radius = t * 1.5;
      spiralPoints.push(new THREE.Vector3(
        Math.cos(angle) * radius - 1.8,
        Math.sin(angle) * radius,
        Math.cos(angle * 0.5) * 0.3
      ));
    }
    
    const spiralGeometry = createLineGeometry(spiralPoints);
    const spiralMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uWidth: { value: 8 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uMouse: { value: mouse },
        uColor: { value: new THREE.Color(0x00ffff) },
        uStart: { value: 0.0 },
        uEnd: { value: 1.0 }
      },
      vertexShader,
      fragmentShader,
      transparent: true,
      side: THREE.DoubleSide
    });
    
    const spiralLine = new THREE.Mesh(spiralGeometry, spiralMaterial);
    scene.add(spiralLine);
    lines.push({ mesh: spiralLine, material: spiralMaterial });
    
    // 2. 波形
    const wavePoints = [];
    for (let i = 0; i < 60; i++) {
      const t = i / 59;
      const x = (t - 0.5) * 4;
      wavePoints.push(new THREE.Vector3(
        x,
        Math.sin(x * 3) * 0.8,
        Math.cos(x * 2) * 0.4
      ));
    }
    
    const waveGeometry = createLineGeometry(wavePoints);
    const waveMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uWidth: { value: 8 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uMouse: { value: mouse },
        uColor: { value: new THREE.Color(0xff00ff) },
        uStart: { value: 0.0 },
        uEnd: { value: 1.0 }
      },
      vertexShader,
      fragmentShader,
      transparent: true,
      side: THREE.DoubleSide
    });
    
    const waveLine = new THREE.Mesh(waveGeometry, waveMaterial);
    scene.add(waveLine);
    lines.push({ mesh: waveLine, material: waveMaterial });
    
    // 3. 3Dヘリックス
    const helixPoints = [];
    for (let i = 0; i < 80; i++) {
      const t = i / 79;
      const angle = t * Math.PI * 5;
      helixPoints.push(new THREE.Vector3(
        Math.cos(angle) * 0.7 + 1.8,
        (t - 0.5) * 3,
        Math.sin(angle) * 0.7
      ));
    }
    
    const helixGeometry = createLineGeometry(helixPoints);
    const helixMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uWidth: { value: 8 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uMouse: { value: mouse },
        uColor: { value: new THREE.Color(0xffff00) },
        uStart: { value: 0.0 },
        uEnd: { value: 1.0 }
      },
      vertexShader,
      fragmentShader,
      transparent: true,
      side: THREE.DoubleSide
    });
    
    const helixLine = new THREE.Mesh(helixGeometry, helixMaterial);
    scene.add(helixLine);
    lines.push({ mesh: helixLine, material: helixMaterial });

    // スライダーイベント
    startSlider.addEventListener('input', (e) => {
      const start = parseFloat(e.target.value);
      lines.forEach(({ material }) => {
        material.uniforms.uStart.value = start;
      });
      isAnimating = false;
    });

    endSlider.addEventListener('input', (e) => {
      const end = parseFloat(e.target.value);
      lines.forEach(({ material }) => {
        material.uniforms.uEnd.value = end;
      });
      isAnimating = false;
    });

    // アニメーションボタン
    animateBtn.addEventListener('click', () => {
      isAnimating = !isAnimating;
      if (isAnimating) {
        animationStart = performance.now();
        animateBtn.textContent = 'アニメーション停止';
      } else {
        animateBtn.textContent = 'アニメーション開始';
      }
    });

    // アニメーションループ
    function animate() {
      requestAnimationFrame(animate);
      
      const time = performance.now() * 0.001;
      
      if (isAnimating) {
        const elapsed = performance.now() - animationStart;
        const progress = (elapsed % animationDuration) / animationDuration;
        
        // 描画アニメーション: 0→1に伸びる
        const start = Math.max(0, progress - 0.3);
        const end = progress;
        
        lines.forEach(({ material }) => {
          material.uniforms.uStart.value = start;
          material.uniforms.uEnd.value = end;
          material.uniforms.uTime.value = time;
        });
        
        startSlider.value = start;
        endSlider.value = end;
        offsetValue.textContent = `Start: ${start.toFixed(2)} | End: ${end.toFixed(2)}`;
      } else {
        lines.forEach(({ material }) => {
          material.uniforms.uTime.value = time;
        });
      }
      
      renderer.render(scene, camera);
    }

    // リサイズ対応
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
      lines.forEach(({ material }) => {
        material.uniforms.uResolution.value = resolution;
      });
    });

    animate();
  </script>
</body>
</html>