<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Line Shader Demo</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="info">
    マウスドラッグで回転<br>
    ビルボード線シェーダー
  </div>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';

    // 頂点シェーダー
    const vertexShader = `
      precision highp float;
      
      uniform float uTime;
      uniform float uWidth;
      uniform vec2 uResolution;
      uniform vec2 uMouse;
      
      attribute vec3 aPrev;
      attribute vec3 aNext;
      attribute float aSide;
      attribute float aAlpha;
      
      varying float vAlpha;
      varying float vSide;
      
      mat3 rotateY(float angle) {
        float s = sin(angle);
        float c = cos(angle);
        return mat3(
          c, 0.0, s,
          0.0, 1.0, 0.0,
          -s, 0.0, c
        );
      }
      
      mat3 rotateX(float angle) {
        float s = sin(angle);
        float c = cos(angle);
        return mat3(
          1.0, 0.0, 0.0,
          0.0, c, -s,
          0.0, s, c
        );
      }
      
      void main() {
        // マウスによる回転
        vec3 pos = position;
        vec3 prev = aPrev;
        vec3 next = aNext;
        
        pos = rotateY(uMouse.x) * pos;
        pos = rotateX(uMouse.y) * pos;
        prev = rotateY(uMouse.x) * prev;
        prev = rotateX(uMouse.y) * prev;
        next = rotateY(uMouse.x) * next;
        next = rotateX(uMouse.y) * next;
        
        // ビュー・プロジェクション変換
        vec4 currMV = modelViewMatrix * vec4(pos, 1.0);
        vec4 prevMV = modelViewMatrix * vec4(prev, 1.0);
        vec4 nextMV = modelViewMatrix * vec4(next, 1.0);
        
        vec4 clipCurr = projectionMatrix * currMV;
        vec4 clipPrev = projectionMatrix * prevMV;
        vec4 clipNext = projectionMatrix * nextMV;
        
        // NDC空間に変換
        vec2 ndcCurr = clipCurr.xy / clipCurr.w;
        vec2 ndcPrev = clipPrev.xy / clipPrev.w;
        vec2 ndcNext = clipNext.xy / clipNext.w;
        
        // 線の方向を計算
        vec2 dir = normalize(ndcNext - ndcPrev);
        if (length(ndcNext - ndcPrev) < 0.0001) {
          dir = vec2(1.0, 0.0);
        }
        
        // 垂直方向のオフセット（ビルボード）
        vec2 normal = vec2(-dir.y, dir.x);
        
        // ピクセル単位でのオフセット
        vec2 ndcPerPixel = 2.0 / uResolution;
        vec2 offset = normal * aSide * uWidth * ndcPerPixel;
        
        vec4 finalPos = clipCurr;
        finalPos.xy += offset * clipCurr.w;
        
        gl_Position = finalPos;
        
        vAlpha = aAlpha;
        vSide = aSide;
      }
    `;

    // フラグメントシェーダー
    const fragmentShader = `
      precision highp float;
      
      uniform vec3 uColor;
      
      varying float vAlpha;
      varying float vSide;
      
      void main() {
        // グラデーション
        vec3 color = mix(uColor * 0.8, uColor * 1.2, vAlpha);
        
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // ラインジオメトリを作成する関数
    function createLineGeometry(points) {
      const positions = [];
      const prevPositions = [];
      const nextPositions = [];
      const sides = [];
      const alphas = [];
      const indices = [];
      
      const numPoints = points.length;
      
      for (let i = 0; i < numPoints; i++) {
        const curr = points[i];
        const prev = i > 0 ? points[i - 1] : points[i];
        const next = i < numPoints - 1 ? points[i + 1] : points[i];
        
        const alpha = i / (numPoints - 1);
        
        // 各点から2つの頂点を作成（両側）
        for (let side = 0; side < 2; side++) {
          positions.push(curr.x, curr.y, curr.z);
          prevPositions.push(prev.x, prev.y, prev.z);
          nextPositions.push(next.x, next.y, next.z);
          sides.push(side === 0 ? 1 : -1);
          alphas.push(alpha);
        }
        
        // インデックス（四角形を2つの三角形に）
        if (i < numPoints - 1) {
          const base = i * 2;
          indices.push(base, base + 1, base + 2);
          indices.push(base + 2, base + 1, base + 3);
        }
      }
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('aPrev', new THREE.Float32BufferAttribute(prevPositions, 3));
      geometry.setAttribute('aNext', new THREE.Float32BufferAttribute(nextPositions, 3));
      geometry.setAttribute('aSide', new THREE.Float32BufferAttribute(sides, 1));
      geometry.setAttribute('aAlpha', new THREE.Float32BufferAttribute(alphas, 1));
      geometry.setIndex(indices);
      
      return geometry;
    }

    // シーンのセットアップ
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 6;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // マウス操作
    const mouse = new THREE.Vector2(0, 0);
    let isDragging = false;
    
    renderer.domElement.addEventListener('mousedown', () => isDragging = true);
    renderer.domElement.addEventListener('mouseup', () => isDragging = false);
    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        mouse.x += e.movementX * 0.005;
        mouse.y += e.movementY * 0.005;
        mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
      }
    });
    
    // タッチ操作
    let lastTouch = null;
    renderer.domElement.addEventListener('touchstart', (e) => {
      isDragging = true;
      lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    });
    renderer.domElement.addEventListener('touchend', () => {
      isDragging = false;
      lastTouch = null;
    });
    renderer.domElement.addEventListener('touchmove', (e) => {
      if (isDragging && lastTouch) {
        const touch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        mouse.x += (touch.x - lastTouch.x) * 0.005;
        mouse.y += (touch.y - lastTouch.y) * 0.005;
        mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
        lastTouch = touch;
      }
    });

    // 複数の線を作成
    const lines = [];
    
    // 1. シンプルなスパイラル
    const spiralPoints = [];
    for (let i = 0; i < 50; i++) {
      const t = i / 49;
      const angle = t * Math.PI * 3;
      const radius = t * 1.5;
      spiralPoints.push(new THREE.Vector3(
        Math.cos(angle) * radius - 1.5,
        Math.sin(angle) * radius,
        0
      ));
    }
    
    const spiralGeometry = createLineGeometry(spiralPoints);
    const spiralMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uWidth: { value: 8 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uMouse: { value: mouse },
        uColor: { value: new THREE.Color(0x00ffff) }
      },
      vertexShader,
      fragmentShader,
      side: THREE.DoubleSide
    });
    
    const spiralLine = new THREE.Mesh(spiralGeometry, spiralMaterial);
    scene.add(spiralLine);
    lines.push({ mesh: spiralLine, material: spiralMaterial });
    
    // 2. サイン波
    const wavePoints = [];
    for (let i = 0; i < 40; i++) {
      const t = i / 39;
      const x = (t - 0.5) * 3;
      wavePoints.push(new THREE.Vector3(
        x + 1.5,
        Math.sin(x * 4) * 0.8,
        0
      ));
    }
    
    const waveGeometry = createLineGeometry(wavePoints);
    const waveMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uWidth: { value: 8 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uMouse: { value: mouse },
        uColor: { value: new THREE.Color(0xff00ff) }
      },
      vertexShader,
      fragmentShader,
      side: THREE.DoubleSide
    });
    
    const waveLine = new THREE.Mesh(waveGeometry, waveMaterial);
    scene.add(waveLine);
    lines.push({ mesh: waveLine, material: waveMaterial });
    
    // 3. 3Dヘリックス
    const helixPoints = [];
    for (let i = 0; i < 60; i++) {
      const t = i / 59;
      const angle = t * Math.PI * 4;
      helixPoints.push(new THREE.Vector3(
        Math.cos(angle) * 0.6,
        (t - 0.5) * 2.5,
        Math.sin(angle) * 0.6
      ));
    }
    
    const helixGeometry = createLineGeometry(helixPoints);
    const helixMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uWidth: { value: 8 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uMouse: { value: mouse },
        uColor: { value: new THREE.Color(0xffff00) }
      },
      vertexShader,
      fragmentShader,
      side: THREE.DoubleSide
    });
    
    const helixLine = new THREE.Mesh(helixGeometry, helixMaterial);
    scene.add(helixLine);
    lines.push({ mesh: helixLine, material: helixMaterial });

    // アニメーションループ
    function animate() {
      requestAnimationFrame(animate);
      
      const time = performance.now() * 0.001;
      
      lines.forEach(({ material }) => {
        material.uniforms.uTime.value = time;
      });
      
      renderer.render(scene, camera);
    }

    // リサイズ対応
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
      lines.forEach(({ material }) => {
        material.uniforms.uResolution.value = resolution;
      });
    });

    animate();
  </script>
</body>
</html>